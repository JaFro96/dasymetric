---
title: "Data Preparation and Dasymetric Maps"
author: "Jannis Fröhlking"
date: "2021-08-17"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data Preparation and Dasymetric Maps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r chunk-options, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 7,
  fig.align="center"
)
```

```{r setup}
library(areal)
library(dasymetric)
library(sf)
library(tmap)
library(dplyr)
```

Dasymetric mapping is a mapping technique that  redistribute spatially extensive data using ancillary information to better represent an underlying statistical surface (Petrov, 2012). 

This vignette:

* describes how to prepare land use data as ancillary information
* creates a dasymetric map of the population in Münster
* compares the outcome with the true population counts and with a naive area-weighted interpolation

## Data preparation

Population data for the districts in Münster can be obtained by their [open data platform](https://opendata.stadt-muenster.de/dataset/geokoordinaten-der-stadtteil-grenzen-geometriedaten-der-kleinr%C3%A4umigen-gebietsgliederung).

```{r districts}
data(population_counts)
tmap::tm_shape(population_counts) + tmap::tm_polygons("population")
```

The European Union's Earth Observation Programme - Copernicus - offers freely and openly accessible services that are based on in situ and on satellite data. One of the six thematic services is land monitoring, which provides information on land cover in 44 classes. The latest product is based on Sentinel-2 satellite data from 2018 (European Environment Agency, 2018). The German _Bundesamt für Kartographie und Geodäsie_ provides data with the same nomenclature based on _Landbedeckungsmodell Deutschland 2018 (LBM-DE2018)_ [product](https://gdz.bkg.bund.de/index.php/default/digitale-geodaten/digitale-landschaftsmodelle/corine-land-cover-5-ha-stand-2018-clc5-2018.html) with a geometric detail of 5 hectare minimum mapping unit.

```{r land-use}
data(corine_18)
grouped_cor = corine_18 |> dplyr::group_by(CLC18) |> dplyr::summarize(geometry = sf::st_union(geometry))
class_names = c("Continuous urban fabric","Discontinuous urban fabric",
                "Industrial or commercial units","Road and rail networks and associated land",
                "Port areas","Airports"," Mineral extraction sites","Dump sites",
                "Green urban areas","Sport and leisure facilities",
                "Non-irrigated arable land","Fruit trees and berry plantations",
                "Pastures","Broad-leaved forest","Coniferous forest","Mixed forest",
                "Natural grassland","Transitional woodland-scrub","Inland marshes",
                "Peat bogs","Water courses","Water bodies")
grouped_cor$class_names = class_names
tmap::tmap_mode("view")
tmap::tm_shape(grouped_cor) + tmap::tm_polygons("class_names")
```

For the following analysis we assume that people live in the two **urban fabric** land cover classes  ( _Continuous urban fabric_ , 111) and _Discontinuous urban fabric_ , 112).

```{r prepare-landuse}
urban_fabric = prep_landuse(grouped_cor)
tmap::tmap_mode("plot")
tmap::tm_shape(population_counts) + 
  tmap::tm_borders() + 
  tmap::tm_shape(urban_fabric) + 
  tmap::tm_polygons("class_names") + 
  tmap::tm_layout(frame.lwd = 3, legend.position = c("right", "top"))
```

## Create dasymetric map
```{r dasymetric-map}
# Create source object: Münster with its population
source_geom = sf::st_union(population_counts)
source = sf::st_sf(ID = 1, pop_prediction = sum(population_counts["population"]$population), source_geom)

dm_pop = dasymetric_map(population_counts, source, urban_fabric, extensive = "pop_prediction")
tmap::tm_shape(dm_pop) + tmap::tm_polygons("pop_prediction", title = "DM-interpolation")
# plot(dm_pop["pop_prediction"],main="Dasymetric population map based on land use information (2018)")
```

## Compare the outcome
```{r comparison}
dm_pop$pred_inaccuracy = abs(dm_pop$population - dm_pop$pop_prediction)
# st_geometry(dm_pop) = NULL
dm_pop|> select(District = NAME_STATI, Prediction_Inaccuracy_Dasymetric_Mapping = pred_inaccuracy)
```

Comparison with areal-weighted interpolation
```{r aw-interpolation, echo = FALSE, messages = FALSE}
aw_pop = areal::aw_interpolate(population_counts,NR_STATIST,source = source, sid = ID,weight = "sum", extensive = "pop_prediction", output = "sf")
tmap::tm_shape(aw_pop) + tmap::tm_polygons("pop_prediction", title = "AW-interpolation")
```

```{r}
aw_pop$pred_inaccuracy = abs(aw_pop$population - aw_pop$pop_prediction)
# st_geometry(aw_pop) = NULL
errors = st_join(aw_pop|> select(District = NAME_STATI, Prediction_Inaccuracy_AW_Interpolation = pred_inaccuracy),dm_pop|> select(District = NAME_STATI, Prediction_Inaccuracy_Dasymetric_Mapping = pred_inaccuracy), largest = TRUE)
cat("Absolute error of aw-interpolation: ",sum(errors$Prediction_Inaccuracy_AW_Interpolation))
cat("Absolute error of dasymetric mapping: ",sum(errors$Prediction_Inaccuracy_Dasymetric_Mapping))
errors
err1 = tmap::tm_shape(errors) + tmap::tm_polygons("Prediction_Inaccuracy_AW_Interpolation", title = "Absolute Errors (AW)")
err2 = tmap::tm_shape(errors) + tmap::tm_polygons("Prediction_Inaccuracy_Dasymetric_Mapping", title = "Absolute Errors (DM)")
tmap_arrange(err1,err2, ncol = 2)
```
